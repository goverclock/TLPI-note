27.1 如下 shell 会话的最后一条命令使用程序清单 27-3 程序来执行程序 xyz。结果如何？

原书答案:execvp()函数首先不能执行 dir1 目录中的文件 xyz，因为该目录的执行权限遭禁。
因此会继续搜索目录 dir2，并成功执行文件 xyz。

书中原文:函数 execvp()和 execlp()会在 PATH 包含的每个目录中搜索文件，从列表开头的目录开始，**直至成功执行了既定文件**.

27.4 下列代码会有什么效果？在何种情况下会起作用？

没有什么特别的地方,效果就是产生了一个直接由init收养的孙进程,省去了对wait的调用.

原书答案:

使用这一代码序列可能存在这种用途：如果需要创建子进程，而稍后又无法等待它，那么使用这一代码序列可以保证不会产生僵尸进程。此类需求的例子之一是：父进程执行了一些程序，又无法保证对其执行 wait (而且也不想将 SIGCHLD 的信号处置置为 SIG_IGN，因为对于 exec()之后遭忽视的 SIGCHLD 的信号处置，SUSv3 并未规范。) 

27.5 运行如下程序时无输出。试问原因何在？

因为execlp替换掉了进程的数据段,stdio的缓冲区就位于这一部分.
