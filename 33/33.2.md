假设一个线程使用 fork()创建了一个子进程。当子进程终止时，可以保证由此产生的
SIGCHLD 信号一定会发送给调用 fork()的线程吗（可以用进程中的其他线程做对比）？

复制一段书中原文来回答:

- 信号动作属于进程层面。如果某进程的任一线程收到任何未经（特殊）处理的信号，且其缺省动作为 stop 或 terminate，那么将停止或者终止该进程的所有线程。

- 对信号的处置属于进程层面，进程中的所有线程共享对每个信号的处置设置。如果某一线程使用函数 sigaction()为某类信号（比如，SIGINT）创建了处理函数，那么当收到 SIGINT 时，任何线程都会去调用该处理函数。与之类似，如果将对信号的处置设置为忽略（ignore），那么所有线程都会忽略该信号。

- 信号的发送既可针对整个进程，也可针对某个特定线程。满足如下三者之一的信号当属面向线程的。

    - 信号的产生源于线程上下文中对特定硬件指令的执行（即 22.4 节所描述的硬件异常：SIGBUS、SIGFPE、SIGILL 和 SIGSEGV）。

    - 当线程试图对已断开的（broken pipe）管道进行写操作时所产生的 SIGPIPE 信号。

    - 由函数 pthread_kill()或 pthread_sigqueue()所发出的信号，这些函数（由 33.2.3 节描述）允许线程向同一进程下的其他线程发送信号。由其他机制产生的所有信号都是面向进程的。例如，其他进程通过调用 kill()或者sigqueue()所发送的信号；用户键入特殊的终端字符所产生的信号，诸如 SIGINT和 SIGTSTP；还有一些信号由软件事件产生，例如终端窗口大小的调整（SIGWINCH）或者定时器到期（例如，SIGALRM）。

- 当多线程程序收到一个信号，且该进程已然为此信号创建了信号处理程序时，内核会任选一条线程来接收这一信号，并在该线程中调用信号处理程序对其进行处理。这种行为与信号的原始语义保持了一致。让进程针对单个信号重复处理多次是没有意义的。

也就是说信号可能会发给所有线程.
